{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"LiquidHaskell \u00b6 LiquidHaskell ( LH ) refines Haskell's types with logical predicates that let you enforce important properties at compile time. See the blog for examples. Quick Start \u00b6 Read the below for more details on how to: Install external software dependencies required by LH Install and use LH as a GHC Plugin Use the command line options supported by LH Write refinement type specifications Learn \u00b6 The following links are a quick way to play with and learn about LH: Try online in your browser Splash page with examples and link to blog Andres Loeh's Tutorial If the above whets your appetite, you may enjoy working through the following longer tutorials: 120 minute workshop with more examples Long ish Tutorial Get involved \u00b6 If you are interested to contribute to LH and its ecosystem, you may want to: Read the contribution guidelines Read our developers' guide to LH Join the LH community to discuss issues related to LH","title":"Home"},{"location":"#liquidhaskell","text":"LiquidHaskell ( LH ) refines Haskell's types with logical predicates that let you enforce important properties at compile time. See the blog for examples.","title":"LiquidHaskell"},{"location":"#quick-start","text":"Read the below for more details on how to: Install external software dependencies required by LH Install and use LH as a GHC Plugin Use the command line options supported by LH Write refinement type specifications","title":"Quick Start"},{"location":"#learn","text":"The following links are a quick way to play with and learn about LH: Try online in your browser Splash page with examples and link to blog Andres Loeh's Tutorial If the above whets your appetite, you may enjoy working through the following longer tutorials: 120 minute workshop with more examples Long ish Tutorial","title":"Learn"},{"location":"#get-involved","text":"If you are interested to contribute to LH and its ecosystem, you may want to: Read the contribution guidelines Read our developers' guide to LH Join the LH community to discuss issues related to LH","title":"Get involved"},{"location":"community/","text":"Community \u00b6 If you have any questions, you can: Join the Liquid Haskell slack channel Mail the users mailing list Alternatively, feel free to drop Ranjit Jhala or Niki Vazou an email.","title":"Community"},{"location":"community/#community","text":"If you have any questions, you can: Join the Liquid Haskell slack channel Mail the users mailing list Alternatively, feel free to drop Ranjit Jhala or Niki Vazou an email.","title":"Community"},{"location":"contributing/","text":"Get involved \u00b6 We are excited for you to try LH! In this section you can find instructions on how to submit your first PR as well as practical instructions on how develop LiquidHaskell. Hacking on LiquidHaskell \u00b6 If you want to extend LH to fix a bug or provide a new feature, you might be interested in reading our Developer's guide . Reporting a bug \u00b6 If something doesn't work as it should, please consider opening a github issue to let us know. If possible, try to: Try to use a descriptive title; State as clearly as possible what is the problem you are facing; Provide a small Haskell file producing the issue; Write down the expected behaviour vs the actual behaviour; If possible, let us know if you have used the plugin or the executable and which GHC version you are using. Your first Pull Request \u00b6 We are thrilled to get PRs! Please follow these guidelines, as doing so will increase the chances of having your PR accepted: The main LH repo lives here Please create pull requests against the develop branch. Please be sure to include test cases that illustrate the effect of the PR e.g. show new features that that are supported or how it fixes some previous issue If the PR adds a LIQUID pragma or option, please also add documentation e.g. in options.md or specifications.md Ask for help \u00b6 If you have further questions or you just need help, you can always reach out to the community .","title":"Get Involved"},{"location":"contributing/#get-involved","text":"We are excited for you to try LH! In this section you can find instructions on how to submit your first PR as well as practical instructions on how develop LiquidHaskell.","title":"Get involved"},{"location":"contributing/#hacking-on-liquidhaskell","text":"If you want to extend LH to fix a bug or provide a new feature, you might be interested in reading our Developer's guide .","title":"Hacking on LiquidHaskell"},{"location":"contributing/#reporting-a-bug","text":"If something doesn't work as it should, please consider opening a github issue to let us know. If possible, try to: Try to use a descriptive title; State as clearly as possible what is the problem you are facing; Provide a small Haskell file producing the issue; Write down the expected behaviour vs the actual behaviour; If possible, let us know if you have used the plugin or the executable and which GHC version you are using.","title":"Reporting a bug"},{"location":"contributing/#your-first-pull-request","text":"We are thrilled to get PRs! Please follow these guidelines, as doing so will increase the chances of having your PR accepted: The main LH repo lives here Please create pull requests against the develop branch. Please be sure to include test cases that illustrate the effect of the PR e.g. show new features that that are supported or how it fixes some previous issue If the PR adds a LIQUID pragma or option, please also add documentation e.g. in options.md or specifications.md","title":"Your first Pull Request"},{"location":"contributing/#ask-for-help","text":"If you have further questions or you just need help, you can always reach out to the community .","title":"Ask for help"},{"location":"develop/","text":"Developers' Guide \u00b6 Here are some notes that are generally useful for people developing LH itself. Fast (re)compilation \u00b6 When working on the liquidhaskell library, usually all we want is to make changes and quickly recompile only the bare minimum, to try out new ideas. Using a fully-fledged GHC plugin doesn't help in this sense, because packages like liquid-base or liquid-ghc-prim all have a direct dependency on liquidhaskell , and therefore every time the latter changes, an expensive rebuild of those packages is triggered, which might become tedious overtime. To mitigate this, we offer a faster, \"dev-style\" build mode which is based on the assumption that most changes to the liquidhaskell library do not alter the validity of already-checked libraries, and therefore things like liquid-base and liquid-ghc-prim can be considered \"static assets\", avoiding the need for a recompilation. In other terms, we explicitly disable recompilation of any of the liquid-* ancillary library in dev mode, so that rebuilds would also influence the liquidhaskell library. Usage and recommended workflow \u00b6 This is how you can use this: To begin with, perform a full build of all the libraries, by doing either cabal v2-build or stack build , without specifying any extra environment variables from the command line. This is needed to ensure that we things like liquid-base and liquid-ghc-prim are compiled at least once, as we would need the refinements they contain to correctly checks other downstream programs; At this point, the content of the liquid-* packages is considered \"trusted\" and \"frozen\", until you won't force another full, non-dev build; In order to quickly test changes to the liquidhaskell library without recompiling the liquid-* packages, we need to start a build passing the LIQUID_DEV_MODE env var as part of the build command. Examples: Stack \u00b6 env LIQUID_DEV_MODE=true stack build Cabal \u00b6 LIQUID_DEV_MODE=true cabal v2-build It's also possible (but not recommended) to add LIQUID_DEV_MODE to .bashrc or similar, but this would permanently disable building the liquid-* packages, and this might silently mask breaking changes to the liquidhaskell library that would manifest only when compiling these other packages. If you wish to force building all the libraries again, it's sufficient to issue the same builds commands without the LIQUID_DEV_MODE . How To Run Regression Tests \u00b6 You can run all the tests by $ stack test To pass in specific parameters and run a subset of the tests $ stack test liquidhaskell --fast --test-arguments \"--liquid-opts --no-termination -p Unit\" Or your favorite number of threads, depending on cores etc. You can directly extend and run the tests by modifying tests/test.hs How to Profile \u00b6 Build with profiling on $ stack build liquidhaskell --fast --profile Run with profiling $ stack exec -- liquid range.hs +RTS -hc -p $ stack exec -- liquid range.hs +RTS -hy -p Followed by this which shows the stats file $ more liquid.prof or by this to see the graph $ hp2ps -e8in -c liquid.hp $ gv liquid.ps etc. How to Get Stack Traces On Exceptions \u00b6 Build with profiling on $ stack build liquidhaskell --fast --profile Run with backtraces $ liquid +RTS -xc -RTS foo.hs stack exec -- liquid List00.hs +RTS -p -xc -RTS Working With Submodules \u00b6 To update the liquid-fixpoint submodule, run: cd ./liquid-fixpoint git fetch --all git checkout <remote>/<branch> cd .. This will update liquid-fixpoint to the latest version on <branch> (usually master ) from <remote> (usually origin ). After updating liquid-fixpoint , make sure to include this change in a commit! Running: git add ./liquid-fixpoint will save the current commit hash of liquid-fixpoint in your next commit to the liquidhaskell repository. For the best experience, don't make changes directly to the ./liquid-fixpoint submodule, or else git may get confused. Do any liquid-fixpoint development inside a separate clone/copy elsewhere. If something goes wrong, run: rm -r ./liquid-fixpoint git submodule update --init to blow away your copy of the liquid-fixpoint submodule and revert to the last saved commit hash. Want to work fully offline? git lets you add a local directory as a remote. Run: cd ./liquid-fixpoint git remote add local /path/to/your/fixpoint/clone cd .. Then to update the submodule from your local clone, you can run: cd ./liquid-fixpoint git fetch local git checkout local/<branch> cd .. Releasing on Hackage \u00b6 NOTE: The following section is relevant only for few developers, i.e. the ones which are directly involved in the release process. Most contributors can skip this section. We provide a conveniency script to upload all the liquid-* packages ( including liquid-fixpoint ) on Hackage, in a lockstep fashion. To do so, it's possible to simply run the scripts/release_to_hackage.sh Bash script. The script doesn't accept any argument and it tries to determine the packages to upload by scanning the $PWD for packages named appropriately. It will ask the user for confirmation before proceeding, and stack upload will be used under the hood.","title":"Developers' Guide"},{"location":"develop/#developers-guide","text":"Here are some notes that are generally useful for people developing LH itself.","title":"Developers' Guide"},{"location":"develop/#fast-recompilation","text":"When working on the liquidhaskell library, usually all we want is to make changes and quickly recompile only the bare minimum, to try out new ideas. Using a fully-fledged GHC plugin doesn't help in this sense, because packages like liquid-base or liquid-ghc-prim all have a direct dependency on liquidhaskell , and therefore every time the latter changes, an expensive rebuild of those packages is triggered, which might become tedious overtime. To mitigate this, we offer a faster, \"dev-style\" build mode which is based on the assumption that most changes to the liquidhaskell library do not alter the validity of already-checked libraries, and therefore things like liquid-base and liquid-ghc-prim can be considered \"static assets\", avoiding the need for a recompilation. In other terms, we explicitly disable recompilation of any of the liquid-* ancillary library in dev mode, so that rebuilds would also influence the liquidhaskell library.","title":"Fast (re)compilation"},{"location":"develop/#usage-and-recommended-workflow","text":"This is how you can use this: To begin with, perform a full build of all the libraries, by doing either cabal v2-build or stack build , without specifying any extra environment variables from the command line. This is needed to ensure that we things like liquid-base and liquid-ghc-prim are compiled at least once, as we would need the refinements they contain to correctly checks other downstream programs; At this point, the content of the liquid-* packages is considered \"trusted\" and \"frozen\", until you won't force another full, non-dev build; In order to quickly test changes to the liquidhaskell library without recompiling the liquid-* packages, we need to start a build passing the LIQUID_DEV_MODE env var as part of the build command. Examples:","title":"Usage and recommended workflow"},{"location":"develop/#stack","text":"env LIQUID_DEV_MODE=true stack build","title":"Stack"},{"location":"develop/#cabal","text":"LIQUID_DEV_MODE=true cabal v2-build It's also possible (but not recommended) to add LIQUID_DEV_MODE to .bashrc or similar, but this would permanently disable building the liquid-* packages, and this might silently mask breaking changes to the liquidhaskell library that would manifest only when compiling these other packages. If you wish to force building all the libraries again, it's sufficient to issue the same builds commands without the LIQUID_DEV_MODE .","title":"Cabal"},{"location":"develop/#how-to-run-regression-tests","text":"You can run all the tests by $ stack test To pass in specific parameters and run a subset of the tests $ stack test liquidhaskell --fast --test-arguments \"--liquid-opts --no-termination -p Unit\" Or your favorite number of threads, depending on cores etc. You can directly extend and run the tests by modifying tests/test.hs","title":"How To Run Regression Tests"},{"location":"develop/#how-to-profile","text":"Build with profiling on $ stack build liquidhaskell --fast --profile Run with profiling $ stack exec -- liquid range.hs +RTS -hc -p $ stack exec -- liquid range.hs +RTS -hy -p Followed by this which shows the stats file $ more liquid.prof or by this to see the graph $ hp2ps -e8in -c liquid.hp $ gv liquid.ps etc.","title":"How to Profile"},{"location":"develop/#how-to-get-stack-traces-on-exceptions","text":"Build with profiling on $ stack build liquidhaskell --fast --profile Run with backtraces $ liquid +RTS -xc -RTS foo.hs stack exec -- liquid List00.hs +RTS -p -xc -RTS","title":"How to Get Stack Traces On Exceptions"},{"location":"develop/#working-with-submodules","text":"To update the liquid-fixpoint submodule, run: cd ./liquid-fixpoint git fetch --all git checkout <remote>/<branch> cd .. This will update liquid-fixpoint to the latest version on <branch> (usually master ) from <remote> (usually origin ). After updating liquid-fixpoint , make sure to include this change in a commit! Running: git add ./liquid-fixpoint will save the current commit hash of liquid-fixpoint in your next commit to the liquidhaskell repository. For the best experience, don't make changes directly to the ./liquid-fixpoint submodule, or else git may get confused. Do any liquid-fixpoint development inside a separate clone/copy elsewhere. If something goes wrong, run: rm -r ./liquid-fixpoint git submodule update --init to blow away your copy of the liquid-fixpoint submodule and revert to the last saved commit hash. Want to work fully offline? git lets you add a local directory as a remote. Run: cd ./liquid-fixpoint git remote add local /path/to/your/fixpoint/clone cd .. Then to update the submodule from your local clone, you can run: cd ./liquid-fixpoint git fetch local git checkout local/<branch> cd ..","title":"Working With Submodules"},{"location":"develop/#releasing-on-hackage","text":"NOTE: The following section is relevant only for few developers, i.e. the ones which are directly involved in the release process. Most contributors can skip this section. We provide a conveniency script to upload all the liquid-* packages ( including liquid-fixpoint ) on Hackage, in a lockstep fashion. To do so, it's possible to simply run the scripts/release_to_hackage.sh Bash script. The script doesn't accept any argument and it tries to determine the packages to upload by scanning the $PWD for packages named appropriately. It will ask the user for confirmation before proceeding, and stack upload will be used under the hood.","title":"Releasing on Hackage"},{"location":"install/","text":"How to install \u00b6 This sections documents how to install LH and its dependencies. External software requirements \u00b6 In order to use liquidhaskell , you will need a SMT solver installed on your system. Download and install at least one of: Z3 or Microsoft official binary CVC4 MathSat Note: The SMT solver binary should be on your PATH ; LiquidHaskell will execute it as a child process. Next \u00b6 Once installed, you can now install and use LH as a plugin or legacy executable .","title":"How to install"},{"location":"install/#how-to-install","text":"This sections documents how to install LH and its dependencies.","title":"How to install"},{"location":"install/#external-software-requirements","text":"In order to use liquidhaskell , you will need a SMT solver installed on your system. Download and install at least one of: Z3 or Microsoft official binary CVC4 MathSat Note: The SMT solver binary should be on your PATH ; LiquidHaskell will execute it as a child process.","title":"External software requirements"},{"location":"install/#next","text":"Once installed, you can now install and use LH as a plugin or legacy executable .","title":"Next"},{"location":"legacy/","text":"Installing the Legacy LiquidHaskell Executable \u00b6 We strongly recommend that you use the GHC Plugin available in version 0.8.10 onwards, as the legacy executable is deprecated and has been kept around for backwards compatibility. It will eventually be removed from future LH releases. External software requirements \u00b6 Make sure all the required external software software is installed before proceeding. Installation options \u00b6 You can install the liquid binary via package manager or source. Via Package Manager \u00b6 Simply do: cabal install liquidhaskell We are working to put liquid on stackage . You can designate a specific version of LiquidHaskell to ensure that the correct GHC version is in the environment. For example: cabal install liquidhaskell-0.8.10.1 Build from Source \u00b6 If you want the most recent version, you can build from source as follows, either using stack (recommended) or cabal . In either case: recursively clone the repo: git clone --recursive https://github.com/ucsd-progsys/liquidhaskell.git Go inside the liquidhaskell directory: cd liquidhaskell Build the package: a. with stack : stack install liquidhaskell b. or with cabal : cabal v2-build liquidhaskell Running in GHCi \u00b6 To run inside ghci e.g. when developing do: $ stack ghci liquidhaskell ghci> :m +Language.Haskell.Liquid.Liquid ghci> liquid [\"tests/pos/Abs.hs\"]","title":"Installing the Legacy LiquidHaskell Executable"},{"location":"legacy/#installing-the-legacy-liquidhaskell-executable","text":"We strongly recommend that you use the GHC Plugin available in version 0.8.10 onwards, as the legacy executable is deprecated and has been kept around for backwards compatibility. It will eventually be removed from future LH releases.","title":"Installing the Legacy LiquidHaskell Executable"},{"location":"legacy/#external-software-requirements","text":"Make sure all the required external software software is installed before proceeding.","title":"External software requirements"},{"location":"legacy/#installation-options","text":"You can install the liquid binary via package manager or source.","title":"Installation options"},{"location":"legacy/#via-package-manager","text":"Simply do: cabal install liquidhaskell We are working to put liquid on stackage . You can designate a specific version of LiquidHaskell to ensure that the correct GHC version is in the environment. For example: cabal install liquidhaskell-0.8.10.1","title":"Via Package Manager"},{"location":"legacy/#build-from-source","text":"If you want the most recent version, you can build from source as follows, either using stack (recommended) or cabal . In either case: recursively clone the repo: git clone --recursive https://github.com/ucsd-progsys/liquidhaskell.git Go inside the liquidhaskell directory: cd liquidhaskell Build the package: a. with stack : stack install liquidhaskell b. or with cabal : cabal v2-build liquidhaskell","title":"Build from Source"},{"location":"legacy/#running-in-ghci","text":"To run inside ghci e.g. when developing do: $ stack ghci liquidhaskell ghci> :m +Language.Haskell.Liquid.Liquid ghci> liquid [\"tests/pos/Abs.hs\"]","title":"Running in GHCi"},{"location":"options/","text":"Options and Pragmas \u00b6 LiquidHaskell supports several command line options, to configure the checking. To see all options, run liquid --help . You can pass options in different ways: From the command line , if you use the legacy executable : liquid --opt1 --opt2 ... As a plugin option : ghc-options: -fplugin-opt=LiquidHaskell:--opt1 -fplugin-opt=LiquidHaskell:--opt2 As a pragma , directly added to the source file: {-@ LIQUID \"opt1\" @-} You may also put command line options in the environment variable LIQUIDHASKELL_OPTS . For example, if you add the line: LIQUIDHASKELL_OPTS=\"--diff\" to your .bashrc then, by default, all files will be incrementally checked unless you run with the overriding --full flag (see below). Below, we list the various options and what they are used for. Theorem Proving \u00b6 Options: reflection , ple , ple-local , extensionality Directives: automatic-instances To enable theorem proving, e.g. as described here use the option {-@ LIQUID \"--reflection\" @-} To additionally turn on proof by logical evaluation use the option {-@ LIQUID \"--ple\" @-} You can see many examples of proofs by logical evaluation in benchmarks/popl18/ple/pos This flag is global and will symbolically evaluate all the terms that appear in the specifications. As an alternative, the liquidinstanceslocal flag has local behavior. See {-@ LIQUID \"--ple-local\" @-} will only evaluate terms appearing in the specifications of the function theorem , in the function theorem is annotated for automatic instantiation using the following liquid annotation {-@ automatic-instances theorem @-} To allow reasoning about function extensionality use the --extensionality flag. See test T1577 . {-@ LIQUID \"--extensionality\" @-} Fast Checking \u00b6 Options: fast , nopolyinfer The option --fast or --nopolyinfer greatly recudes verification time, can also reduces precision of type checking. It, per module, deactivates inference of refinements during instantiation of polymorphic type variables. It is suggested to use on theorem proving style when reflected functions are trivially refined. Incremental Checking \u00b6 Options: diff The LiquidHaskell executable supports incremental checking where each run only checks the part of the program that has been modified since the previous run. Each run of liquid saves the file to a .bak file and the subsequent run does a diff to see what has changed w.r.t. the .bak file only generates constraints for the [CoreBind] corresponding to the changed top-level binders and their transitive dependencies. The time savings are quite significant. For example: $ time liquid --notermination -i . Data/ByteString.hs > log 2>&1 real 7m3.179s user 4m18.628s sys 0m21.549s Now if you go and tweak the definition of spanEnd on line 1192 and re-run: $ time liquid --diff --notermination -i . Data/ByteString.hs > log 2>&1 real 0m11.584s user 0m6.008s sys 0m0.696s The diff is only performed against code , i.e. if you only change specifications, qualifiers, measures, etc. liquid -d will not perform any checks. In this case, you may specify individual definitions to verify: $ liquid -b bar -b baz foo.hs This will verify bar and baz , as well as any functions they use. If you always want to run a given file with diff-checking, add the pragma: {-@ LIQUID \"--diff\" @-} Full Checking (DEFAULT) \u00b6 Options: full You can force LiquidHaskell to check the whole file (which is the DEFAULT ) using the --full option. This will override any other --diff incantation elsewhere (e.g. inside the file). If you always want to run a given file with full-checking, add the pragma: {-@ LIQUID \"--full\" @-} Specifying Different SMT Solvers \u00b6 Options: smtsolver By default, LiquidHaskell uses the SMTLIB2 interface for Z3. To run a different solver (supporting SMTLIB2) do: $ liquid --smtsolver=NAME foo.hs Currently, LiquidHaskell supports CVC4 MathSat To use these solvers, you must install the corresponding binaries from the above web-pages into your PATH . You can also build and link against the Z3 API (faster but requires more dependencies). If you do so, you can use that interface with: $ liquid --smtsolver=z3mem foo.hs Short Error Messages \u00b6 Options: short-errors By default, subtyping error messages will contain the inferred type, the expected type -- which is not a super-type, hence the error -- and a context containing relevant variables and their type to help you understand the error. If you don't want the above and instead, want only the source position of the error use --short-errors . Short (Unqualified) Module Names \u00b6 Options: short-names By default, the inferred types will have fully qualified module names. To use unqualified names, much easier to read, use --short-names . Disabling Checks on Functions \u00b6 Directives: ignore You can disable checking of a particular function (e.g. because it is unsafe, or somehow not currently outside the scope of LH) by using the ignore directive. For example, {-@ ignore foo @-} will disable the checking of the code for the top-level binder foo . See tests/pos/Ignores.hs for an example. Totality Check \u00b6 Options: no-totality LiquidHaskell proves the absence of pattern match failures. For example, the definition fromJust :: Maybe a -> a fromJust (Just a) = a is not total and it will create an error message. If we exclude Nothing from its domain, for example using the following specification {-@ fromJust :: {v:Maybe a | (isJust v)} -> a @-} fromJust will be safe. Use the no-totality flag to disable totality checking. Termination Check \u00b6 Options: no-termination By default a termination check is performed on all recursive functions, but you can disable the check with the --no-termination option. See the specifications section for how to write termination specifications. Total Haskell \u00b6 Options: total-Haskell LiquidHaskell provides a total Haskell flag that checks both totallity and termination of the program, overriding a potential no-termination flag. Lazy Variables \u00b6 A variable can be specified as LAZYVAR {-@ LAZYVAR z @-} With this annotation the definition of z will be checked at the points where it is used. For example, with the above annotation the following code is SAFE: foo = if x > 0 then z else x where z = 42 `safeDiv` x x = choose 0 By default, all the variables starting with fail are marked as LAZY, to defer failing checks at the point where these variables are used. No measure fields \u00b6 Options: no-measure-fields When a data type is refined, Liquid Haskell automatically turns the data constructor fields into measures. For example, {-@ data L a = N | C {hd :: a, tl :: L a} @-} will automatically create two measures hd and td . To deactivate this automatic measure definition, and speed up verification, you can use the --no-measure-fields flag. Prune Unsorted Predicates \u00b6 Options: prune-unsorted The --prune-unsorted flag is needed when using measures over specialized instances of ADTs. For example, consider a measure over lists of integers sum :: [Int] -> Int sum [] = 0 sum (x:xs) = 1 + sum xs This measure will translate into strengthening the types of list constructors [] :: {v:[Int] | sum v = 0 } (:) :: x:Int -> xs:[Int] -> {v:[Int] | sum v = x + sum xs} But what if our list is polymorphic [a] and later instantiate to list of ints? The workaround we have right now is to strengthen the polymorphic list with the sum information [] :: {v:[a] | sum v = 0 } (:) :: x:a -> xs:[a] -> {v:[a] | sum v = x + sum xs} But for non numeric a s, refinements like x + sum xs are ill-sorted! We use the flag --prune-unsorted to prune away unsorted expressions (like x + sum xs ) inside refinements. Case Expansion \u00b6 Options: no-case-expand By default LiquidHaskell expands all data constructors to the case statements. For example, given the definition data F = A1 | A2 | .. | A10 LiquidHaskell will expand the code case f of {A1 -> True; _ -> False} to case f of {A1 -> True; A2 -> False; ...; A10 -> False} This expansion can lead to more precise code analysis but it can get really expensive due to code explosion. The --no-case-expand flag prevents this expansion and keeps the user provided cases for the case expression. Higher order logic \u00b6 Options: higherorder The flag --higherorder allows reasoning about higher order functions. Restriction to Linear Arithmetic \u00b6 Options: linear When using z3 as the solver, LiquidHaskell allows for non-linear arithmetic: division and multiplication on integers are interpreted by z3 . To treat division and multiplication as uninterpreted functions use the --linear flag. Counter examples \u00b6 Options: counter-examples Status: experimental When given the --counter-examples flag, LiquidHaskell will attempt to produce counter-examples for the type errors it discovers. For example, see tests/neg/ListElem.hs % liquid --counter-examples tests/neg/ListElem.hs ... tests/neg/ListElem.hs:12:1-8: Error: Liquid Type Mismatch 12 | listElem _ [] = False ^^^^^^^^ Inferred type VV : {VV : Bool | VV == True} VV = True not a subtype of Required type VV : {VV : Bool | Prop VV <=> Set_mem ?b (listElts ?a)} In Context ?a : {?a : [a] | len ?a >= 0} ?a = [1] ?b : a ?b = 0 The --counter-examples flag requires that each type in the context be an instance of GHC.Generics.Generic or Test.Targetable.Targetable (provided as part of LiquidHaskell). LiquidHaskell cannot generate counter-examples for polymorphic types, but will try (naively) to instantiate type variables with Int (as seen in the example above). Generating HTML Output \u00b6 The system produces HTML files with colorized source, and mouseover inferred type annotations, which are quite handy for debugging failed verification attempts. Regular Haskell When you run: liquid foo.hs you get a file foo.hs.html with the annotations. The coloring is done using hscolour . Markdown + Literate Haskell You can also feed in literate haskell files where the comments are in Pandoc markdown . In this case, the tool will run pandoc to generate the HTML from the comments. Of course, this requires that you have pandoc installed as a binary on your system. If not, hscolour is used to render the HTML. It is also possible to generate slide shows from the above. See the slides directory for an example.","title":"Options"},{"location":"options/#options-and-pragmas","text":"LiquidHaskell supports several command line options, to configure the checking. To see all options, run liquid --help . You can pass options in different ways: From the command line , if you use the legacy executable : liquid --opt1 --opt2 ... As a plugin option : ghc-options: -fplugin-opt=LiquidHaskell:--opt1 -fplugin-opt=LiquidHaskell:--opt2 As a pragma , directly added to the source file: {-@ LIQUID \"opt1\" @-} You may also put command line options in the environment variable LIQUIDHASKELL_OPTS . For example, if you add the line: LIQUIDHASKELL_OPTS=\"--diff\" to your .bashrc then, by default, all files will be incrementally checked unless you run with the overriding --full flag (see below). Below, we list the various options and what they are used for.","title":"Options and Pragmas"},{"location":"options/#theorem-proving","text":"Options: reflection , ple , ple-local , extensionality Directives: automatic-instances To enable theorem proving, e.g. as described here use the option {-@ LIQUID \"--reflection\" @-} To additionally turn on proof by logical evaluation use the option {-@ LIQUID \"--ple\" @-} You can see many examples of proofs by logical evaluation in benchmarks/popl18/ple/pos This flag is global and will symbolically evaluate all the terms that appear in the specifications. As an alternative, the liquidinstanceslocal flag has local behavior. See {-@ LIQUID \"--ple-local\" @-} will only evaluate terms appearing in the specifications of the function theorem , in the function theorem is annotated for automatic instantiation using the following liquid annotation {-@ automatic-instances theorem @-} To allow reasoning about function extensionality use the --extensionality flag. See test T1577 . {-@ LIQUID \"--extensionality\" @-}","title":"Theorem Proving"},{"location":"options/#fast-checking","text":"Options: fast , nopolyinfer The option --fast or --nopolyinfer greatly recudes verification time, can also reduces precision of type checking. It, per module, deactivates inference of refinements during instantiation of polymorphic type variables. It is suggested to use on theorem proving style when reflected functions are trivially refined.","title":"Fast Checking"},{"location":"options/#incremental-checking","text":"Options: diff The LiquidHaskell executable supports incremental checking where each run only checks the part of the program that has been modified since the previous run. Each run of liquid saves the file to a .bak file and the subsequent run does a diff to see what has changed w.r.t. the .bak file only generates constraints for the [CoreBind] corresponding to the changed top-level binders and their transitive dependencies. The time savings are quite significant. For example: $ time liquid --notermination -i . Data/ByteString.hs > log 2>&1 real 7m3.179s user 4m18.628s sys 0m21.549s Now if you go and tweak the definition of spanEnd on line 1192 and re-run: $ time liquid --diff --notermination -i . Data/ByteString.hs > log 2>&1 real 0m11.584s user 0m6.008s sys 0m0.696s The diff is only performed against code , i.e. if you only change specifications, qualifiers, measures, etc. liquid -d will not perform any checks. In this case, you may specify individual definitions to verify: $ liquid -b bar -b baz foo.hs This will verify bar and baz , as well as any functions they use. If you always want to run a given file with diff-checking, add the pragma: {-@ LIQUID \"--diff\" @-}","title":"Incremental Checking"},{"location":"options/#full-checking-default","text":"Options: full You can force LiquidHaskell to check the whole file (which is the DEFAULT ) using the --full option. This will override any other --diff incantation elsewhere (e.g. inside the file). If you always want to run a given file with full-checking, add the pragma: {-@ LIQUID \"--full\" @-}","title":"Full Checking (DEFAULT)"},{"location":"options/#specifying-different-smt-solvers","text":"Options: smtsolver By default, LiquidHaskell uses the SMTLIB2 interface for Z3. To run a different solver (supporting SMTLIB2) do: $ liquid --smtsolver=NAME foo.hs Currently, LiquidHaskell supports CVC4 MathSat To use these solvers, you must install the corresponding binaries from the above web-pages into your PATH . You can also build and link against the Z3 API (faster but requires more dependencies). If you do so, you can use that interface with: $ liquid --smtsolver=z3mem foo.hs","title":"Specifying Different SMT Solvers"},{"location":"options/#short-error-messages","text":"Options: short-errors By default, subtyping error messages will contain the inferred type, the expected type -- which is not a super-type, hence the error -- and a context containing relevant variables and their type to help you understand the error. If you don't want the above and instead, want only the source position of the error use --short-errors .","title":"Short Error Messages"},{"location":"options/#short-unqualified-module-names","text":"Options: short-names By default, the inferred types will have fully qualified module names. To use unqualified names, much easier to read, use --short-names .","title":"Short (Unqualified) Module Names"},{"location":"options/#disabling-checks-on-functions","text":"Directives: ignore You can disable checking of a particular function (e.g. because it is unsafe, or somehow not currently outside the scope of LH) by using the ignore directive. For example, {-@ ignore foo @-} will disable the checking of the code for the top-level binder foo . See tests/pos/Ignores.hs for an example.","title":"Disabling Checks on Functions"},{"location":"options/#totality-check","text":"Options: no-totality LiquidHaskell proves the absence of pattern match failures. For example, the definition fromJust :: Maybe a -> a fromJust (Just a) = a is not total and it will create an error message. If we exclude Nothing from its domain, for example using the following specification {-@ fromJust :: {v:Maybe a | (isJust v)} -> a @-} fromJust will be safe. Use the no-totality flag to disable totality checking.","title":"Totality Check"},{"location":"options/#termination-check","text":"Options: no-termination By default a termination check is performed on all recursive functions, but you can disable the check with the --no-termination option. See the specifications section for how to write termination specifications.","title":"Termination Check"},{"location":"options/#total-haskell","text":"Options: total-Haskell LiquidHaskell provides a total Haskell flag that checks both totallity and termination of the program, overriding a potential no-termination flag.","title":"Total Haskell"},{"location":"options/#lazy-variables","text":"A variable can be specified as LAZYVAR {-@ LAZYVAR z @-} With this annotation the definition of z will be checked at the points where it is used. For example, with the above annotation the following code is SAFE: foo = if x > 0 then z else x where z = 42 `safeDiv` x x = choose 0 By default, all the variables starting with fail are marked as LAZY, to defer failing checks at the point where these variables are used.","title":"Lazy Variables"},{"location":"options/#no-measure-fields","text":"Options: no-measure-fields When a data type is refined, Liquid Haskell automatically turns the data constructor fields into measures. For example, {-@ data L a = N | C {hd :: a, tl :: L a} @-} will automatically create two measures hd and td . To deactivate this automatic measure definition, and speed up verification, you can use the --no-measure-fields flag.","title":"No measure fields"},{"location":"options/#prune-unsorted-predicates","text":"Options: prune-unsorted The --prune-unsorted flag is needed when using measures over specialized instances of ADTs. For example, consider a measure over lists of integers sum :: [Int] -> Int sum [] = 0 sum (x:xs) = 1 + sum xs This measure will translate into strengthening the types of list constructors [] :: {v:[Int] | sum v = 0 } (:) :: x:Int -> xs:[Int] -> {v:[Int] | sum v = x + sum xs} But what if our list is polymorphic [a] and later instantiate to list of ints? The workaround we have right now is to strengthen the polymorphic list with the sum information [] :: {v:[a] | sum v = 0 } (:) :: x:a -> xs:[a] -> {v:[a] | sum v = x + sum xs} But for non numeric a s, refinements like x + sum xs are ill-sorted! We use the flag --prune-unsorted to prune away unsorted expressions (like x + sum xs ) inside refinements.","title":"Prune Unsorted Predicates"},{"location":"options/#case-expansion","text":"Options: no-case-expand By default LiquidHaskell expands all data constructors to the case statements. For example, given the definition data F = A1 | A2 | .. | A10 LiquidHaskell will expand the code case f of {A1 -> True; _ -> False} to case f of {A1 -> True; A2 -> False; ...; A10 -> False} This expansion can lead to more precise code analysis but it can get really expensive due to code explosion. The --no-case-expand flag prevents this expansion and keeps the user provided cases for the case expression.","title":"Case Expansion"},{"location":"options/#higher-order-logic","text":"Options: higherorder The flag --higherorder allows reasoning about higher order functions.","title":"Higher order logic"},{"location":"options/#restriction-to-linear-arithmetic","text":"Options: linear When using z3 as the solver, LiquidHaskell allows for non-linear arithmetic: division and multiplication on integers are interpreted by z3 . To treat division and multiplication as uninterpreted functions use the --linear flag.","title":"Restriction to Linear Arithmetic"},{"location":"options/#counter-examples","text":"Options: counter-examples Status: experimental When given the --counter-examples flag, LiquidHaskell will attempt to produce counter-examples for the type errors it discovers. For example, see tests/neg/ListElem.hs % liquid --counter-examples tests/neg/ListElem.hs ... tests/neg/ListElem.hs:12:1-8: Error: Liquid Type Mismatch 12 | listElem _ [] = False ^^^^^^^^ Inferred type VV : {VV : Bool | VV == True} VV = True not a subtype of Required type VV : {VV : Bool | Prop VV <=> Set_mem ?b (listElts ?a)} In Context ?a : {?a : [a] | len ?a >= 0} ?a = [1] ?b : a ?b = 0 The --counter-examples flag requires that each type in the context be an instance of GHC.Generics.Generic or Test.Targetable.Targetable (provided as part of LiquidHaskell). LiquidHaskell cannot generate counter-examples for polymorphic types, but will try (naively) to instantiate type variables with Int (as seen in the example above).","title":"Counter examples"},{"location":"options/#generating-html-output","text":"The system produces HTML files with colorized source, and mouseover inferred type annotations, which are quite handy for debugging failed verification attempts. Regular Haskell When you run: liquid foo.hs you get a file foo.hs.html with the annotations. The coloring is done using hscolour . Markdown + Literate Haskell You can also feed in literate haskell files where the comments are in Pandoc markdown . In this case, the tool will run pandoc to generate the HTML from the comments. Of course, this requires that you have pandoc installed as a binary on your system. If not, hscolour is used to render the HTML. It is also possible to generate slide shows from the above. See the slides directory for an example.","title":"Generating HTML Output"},{"location":"plugin/","text":"Installing and Running LiquidHaskell \u00b6 As of LH version 0.8.10, mirroring GHC-8.10, LiquidHaskell is available as a GHC compiler plugin . (We still offer the old legacy executable , to give users enough time to complete migrations to the new system.) Benefits \u00b6 As a GHC plugin, you simply specify liquidhaskell as one of the dependencies of your project in the cabal file, after which stack or cabal automatically: Install Liquidhaskell Tells GHC to use LH during compilation Displays refinement type errors during compilation Reuses ghci , ghcid and all GHC compatible tooling for your favorite editor. We recommend switching to the new compiler plugin as soon as possible. External software requirements \u00b6 Make sure all the required external software software is installed before proceeding. Getting started \u00b6 We offer a detailed \"getting started\" walkthrough in the form of a Haskell module with a lot of comments, written in prose. You can read it here . Examples \u00b6 The following concrete examples show the source plugin in action: Sample package Sample client package You can use the .cabal , stack.yaml and cabal.project files in the sample packages to see how to write the equivalent files for your own codebase. Editor Support \u00b6 One of the added benefit of the plugin is that you get to automatically reuse all ghc-based support for your editor as is. Again, the sample packages include examples for vscode , vim and emacs .","title":"Install"},{"location":"plugin/#installing-and-running-liquidhaskell","text":"As of LH version 0.8.10, mirroring GHC-8.10, LiquidHaskell is available as a GHC compiler plugin . (We still offer the old legacy executable , to give users enough time to complete migrations to the new system.)","title":"Installing and Running LiquidHaskell"},{"location":"plugin/#benefits","text":"As a GHC plugin, you simply specify liquidhaskell as one of the dependencies of your project in the cabal file, after which stack or cabal automatically: Install Liquidhaskell Tells GHC to use LH during compilation Displays refinement type errors during compilation Reuses ghci , ghcid and all GHC compatible tooling for your favorite editor. We recommend switching to the new compiler plugin as soon as possible.","title":"Benefits"},{"location":"plugin/#external-software-requirements","text":"Make sure all the required external software software is installed before proceeding.","title":"External software requirements"},{"location":"plugin/#getting-started","text":"We offer a detailed \"getting started\" walkthrough in the form of a Haskell module with a lot of comments, written in prose. You can read it here .","title":"Getting started"},{"location":"plugin/#examples","text":"The following concrete examples show the source plugin in action: Sample package Sample client package You can use the .cabal , stack.yaml and cabal.project files in the sample packages to see how to write the equivalent files for your own codebase.","title":"Examples"},{"location":"plugin/#editor-support","text":"One of the added benefit of the plugin is that you get to automatically reuse all ghc-based support for your editor as is. Again, the sample packages include examples for vscode , vim and emacs .","title":"Editor Support"},{"location":"specifications/","text":"Writing Specifications \u00b6 This section documents how you can actually annotate new or existing code with refinement types, leveraging the full power of LiquidHaskell. There are a lot of different ways to annotate your code, and so we've included a brief summary of each here. {-@ inline <binding-name> @-} copies a Haskell definition to the refinement logic. ( Jump to: Inlines ) All parts of the definition must already be available to the refinement logic. The definition cannot be recursive. {-@ measure <function-name>[ <refinement-type>] @-} copies a Haskell function to the refinement logic, adds an inferred refinement type to the constructor of the function's first argument, and emits an inferred global invariant related to the refinement. ( Jump to: Measures ) All parts of the definition must already be available to the refinement logic. The function must have only one argument and it must pattern match on the constructors of the type. The function may structurally recurse on the single argument. {-@ reflect <function-name> @-} creates an uninterpreted function of the same name in the refinement logic, copies the implementation to a refinement type alias, and adds a refinement to the type of the uninterpreted function that specifies the type alias as a post-condition. ( See more: Section 2.2 of this paper ) All parts of the definition must already be available to the refinement logic. The function may be recursive. {-@ type <type-alias-head> = <refinement-type> @-} introduces a type alias that looks like Haskell syntax but can contain refinements and may be parameterized over both types and values. ( Jump to: Type Aliases ) {-@ predicate .. @-} introduces something like {-@ type .. @-} . ( Deprecated, use inline instead , Jump to: Predicate Aliases ) {-@ invariant <refinement-type> @-} introduces a globally available refinement which may be used by Liquid Haskel, but is not checked. ( Unchecked , Deprecated , Jump to: Invariants ) {-@ data <data-type-head><termination-measure>[ <data-type-body] @-} introduces a refined datatype, and introduces measures for each field of a record datatype. ( Jump to: Data Refinements ) Optionally you may also add refinements to datatype fields. Optionally you may also add a termination measure to the datatype. {-@ assume <binding-signature-with-refinement-type> @-} introduces a refinement type for the named Haskell definition. ( Unchecked ) For a function, the refinements become pre and post conditions for the functions use. {-@ <binding-signature-with-refinement-type> @-} introduces a refinement type for the named Haskell definition. For a function, the refinements become pre and post conditions for the functions use. This is probably the most used Liquid Haskell annotation! The following sections detail more variety for the uses of the above annotations. Modules WITHOUT code \u00b6 The following section is slightly different depending on whether you are using the plugin (which you should!) or the legacy executable. (Plugin) Adding refinements for external modules \u00b6 See the plugin section, which cointains a link to a walkthrough document that describes how to add refinements for external packages (cfr. \"Providing Specifications for Existing Packages\" ) (Legacy executable) Adding refinements for external modules \u00b6 When checking a file target.hs , you can specify an include directory by liquid -i /path/to/include/ target.hs Now, to write specifications for some external module Foo.Bar.Baz for which you do not have the code , you can create a .spec file at: /path/to/include/Foo/Bar/Baz.spec See, for example, the contents of: include/Prelude.spec include/Data/List.spec include/Data/Vector.spec Note : The above directories are part of the LH prelude, and included by default when running liquid . The .spec mechanism is only for external modules without code, see below for standalone specifications for internal or home * modules. Modules WITH code: Data \u00b6 Write the specification directly into the .hs or .lhs file, above the data definition. See, for example, tests/pos/Map.hs : {-@ data Map k a <l :: k -> k -> Prop, r :: k -> k -> Prop> = Tip | Bin (sz :: Size) (key :: k) (value :: a) (left :: Map <l, r> (k <l key>) a) (right :: Map <l, r> (k <r key>) a) @-} data Map k a = Tip | Bin Size k a (Map k a) (Map k a) You can also write invariants for data type definitions together with the types. For example, see tests/pos/record0.hs : {-@ data LL a = BXYZ { size :: {v: Int | v > 0 } , elems :: {v: [a] | (len v) = size } } @-} Finally you can specify the variance of type variables for data types. For example, see tests/pos/Variance.hs , where data type Foo has four type variables a , b , c , d , specified as invariant, bivariant, covariant and contravariant, respectively. {-@ data variance Foo invariant bivariant covariant contravariant @-} data Foo a b c d Modules WITH code: Functions \u00b6 Write the specification directly into the .hs or .lhs file, above the function definition. For example : {-@ incr :: x:{v: Int | v > 0} -> {v: Int | v > x} @-} incr :: Int -> Int incr x = x + 1 Modules WITH code: Type Classes \u00b6 Write the specification directly into the .hs or .lhs file, above the type class definition. For example : {-@ class Sized s where size :: forall a. x:s a -> {v:Int | v = (size x)} @-} class Sized s where size :: s a -> Int Any measures used in the refined class definition will need to be generic (see Specifying Measures ). As an alternative, you can refine class instances. For example : instance Compare Int where {-@ instance Compare Int where cmax :: Odd -> Odd -> Odd @-} cmax y x = if x >= y then x else y When cmax method is used on Int , liquidHaskell will give it the refined type Odd -> Odd -> Odd . Note that currently liquidHaskell does not allow refining instances of refined classes . Modules WITH code: QuasiQuotation \u00b6 Instead of writing both a Haskell type signature and a LiquidHaskell specification for a function, the lq quasiquoter in the LiquidHaskell module can be used to generate both from just the LiquidHaskell specification. module Nats (nats) where {-@ nats :: [{v:Int | 0 <= v}] @-} nats :: [Int] nats = [1,2,3] can be written as {-# LANGUAGE QuasiQuotes #-} module Nats (nats) where import LiquidHaskell [lq| nats :: [{v:Int | 0 <= v}] |] nats = [1,2,3] and the lq quasiquoter will generate the plain nats :: [Int] when GHC compiles the module. Refined type aliases (see the next section) can also be written inside lq ; for example: {-# LANGUAGE QuasiQuoters #-} module Nats (Nat, nats) where [lq| type Nat = {v:Int | 0 <= v} |] [lq| nats :: [Nat] |] nats = [1,2,3] Here, the lq quasiquoter will generate a plain Haskell type synonym for Nat as well as the refined one. Note that this is still an experimental feature, and currently requires that one depend on LiquidHaskell as a build dependency for your project; the quasiquoter will be split out eventually into an independent, dependency-light package. Also, at this time, writing a type inside lq which refers to a refined type alias for which there is not a plain Haskell type synonym of the same name will result in a \"not in scope\" error from GHC. Standalone Specifications for Internal Modules \u00b6 Recall that the .spec mechanism is only for modules whose code is absent; if code is present then there can be multiple, possibly conflicting specifications. Nevertheless, you may want, for one reason or another, to write (assumed) specifications outside the file implementing the module. You can do this as follows. Lib.hs module Lib (foo) where foo a = a now, instead of a .spec file, just use a haskell module, e.g. LibSpec.hs module LibSpec ( module Lib ) where import Lib -- Don't forget to qualify the name! {-@ Lib.foo :: {v:a | false} -> a @-} and then here's Client.hs module Client where import Lib -- use this if you DON'T want the spec import LibSpec -- use this if you DO want the spec, in addition to OR instead of the previous import. bar = foo 1 -- if you `import LibSpec` then this call is rejected by LH Inductive Predicates \u00b6 Status: very_experimental LH recently added support for Inductive Predicates in the style of Isabelle, Coq etc. These are encoded simply as plain Haskell GADTs but suitably refined. Apologies for the minimal documentation; see the following examples for details: Palindrome Permutations Transitive Closure RegExp Derivatives Type Safety of STLC Implicit Arguments \u00b6 Status: experimental There is experimental support for implicit arguments, solved for with congruence closure. For example, consider Implicit1.hs : {-@ type IntN N = {v:Int | v = N} @-} {-@ foo :: n:Int ~> (() -> IntN n) -> IntN {n+1} @-} foo f = 1 + f () {-@ test1 :: IntN 11 @-} test1 = foo (\\_ -> 10) Here, the refinement on (\\_ -> 10) :: Int -> { v:Int | v = 10 } allows us to solve for n = 10 , the implicit argument to foo . Refinement Type Aliases \u00b6 Predicate Aliases \u00b6 Often, the propositions in the refinements can get rather long and verbose. You can write predicate aliases like so: {-@ predicate Lt X Y = X < Y @-} {-@ predicate Ge X Y = not (Lt X Y) @-} and then use the aliases inside refinements, for example {-@ incr :: x:{v:Int | (Pos v)} -> { v:Int | ((Pos v) && (Ge v x))} @-} incr :: Int -> Int incr x = x + 1 See Data.Map for a more substantial and compelling example. Syntax: The key requirements for type aliases are: Value parameters are specified in upper case: X , Y , Z etc. Failing Specifications \u00b6 The fail b declaration checks that the definition of b is unsafe. E.g., the following is SAFE. {-@ fail unsafe @-} {-@ unsafe :: () -> { 0 == 1 } @-} unsafe :: () -> () unsafe _ = () An error is created if fail definitions are safe or binders defined as fail are used by (failing or not) definitions. Type Aliases \u00b6 Similarly, it is often quite tedious to keep writing {v: Int | v > 0} Thus, LiquidHaskell supports refinement-type aliases of the form: {-@ type Gt N = {v: Int | N < v} @-} {-@ type GeNum a N = {v: a | N <= v} @-} or {-@ type SortedList a = [a]<{\\fld v -> (v >= fld)}> @-} or {-@ type OMap k a = Map <{\\root v -> v < root}, {\\root v -> v > root}> k a @-} or {-@ type MinSPair a = (a, OSplay a) <\\fld -> {v : Splay {v:a|v>fld} | 0=0}> @-} and then use the above in signatures like: {-@ incr: x: Int -> GeNum Int x @-} or {-@ incr: x: Int -> Gt x @-} and: {-@ assert insert :: (Ord a) => a -> SortedList a -> SortedList a @-} see tests/pos/ListSort.hs and: {-@ assert insert :: (Ord k) => k -> a -> OMap k a -> OMap k a @-} see tests/pos/Map.hs Syntax: The key requirements for type aliases are: Type parameters are specified in lower case: a , b , c etc. Value parameters are specified in upper case: X , Y , Z etc. Infix Operators \u00b6 You can define infix types and logical operators in logic Haskell's infix notation . For example, if (+++) is defined as a measure or reflected function, you can use it infix by declaring {-@ infixl 9 +++ @-} Note: infix operators cannot contain the dot character . . If (==>) is a Haskell infix type ( see ) infixr 1 ==> then to use it as infix in the refinements types you need to add the refinement infix notation. {-@ infixr 1 ==> @-} {-@ test :: g:(f ==> g) -> f x -> f y -> () @-} Specifying Measures \u00b6 They can be placed in a .spec file or in a .hs/.lhs file wrapped around {-@ @-} . Value measures: GHC/Base.spec measure len :: forall a. [a] -> GHC.Types.Int len ([]) = 0 len (y:ys) = 1 + len(ys) Propositional measures: tests/pos/LambdaEval.hs {-@ measure isValue :: Expr -> Bool isValue (Const i) = true isValue (Lam x e) = true isValue (Var x) = false isValue (App e1 e2) = false isValue (Plus e1 e2) = false isValue (Fst e) = false isValue (Snd e) = false isValue (Pair e1 e2) = ((? (isValue(e1))) && (? (isValue(e2)))) @-} Raw measures: tests/pos/meas8.hs {-@ measure rlen :: [a] -> Int rlen ([]) = {v | v = 0} rlen (y:ys) = {v | v = (1 + rlen(ys))} @-} Generic measures: tests/pos/Class.hs {-@ class measure size :: a -> Int @-} {-@ instance measure size :: [a] -> Int size ([]) = 0 size (x:xs) = 1 + (size xs) @-} {-@ instance measure size :: Tree a -> Int size (Leaf) = 0 size (Node x l r) = 1 + (size l) + (size r) @-} Note: Measure names do not have to be the same as field name, e.g. we could call the measure sz in the above as shown in tests/pos/Class2.hs . Haskell Functions as Measures (beta): tests/pos/HaskellMeasure.hs Inductive Haskell Functions from Data Types to some type can be lifted to logic {-@ measure llen @-} llen :: [a] -> Int llen [] = 0 llen (x:xs) = 1 + llen xs The above definition: refines list's data constructors types with the llen information, and specifies a singleton type for the haskell function llen :: xs:[a] -> {v:Int | v == llen xs} . If the user specifies another type for llen , say llen :: xs:[a] -> {v:Int | llen xs >= 0} , then the auto generated singleton type is overwritten. Inlines \u00b6 The inline lets you use a Haskell function in a type specification. {-@ inline max @-} {-@ max :: Int -> Int -> Int @-} max :: Int -> Int -> Int max x y = if x > y then x else y For example, if you write the above you can then write a function: {-@ floor :: x:Int -> {v:Int | max 0 x} @-} floor :: Int -> Int floor x | x <= 0 = 0 | otherwise = x That is, you can use the haskell max in the refinement type and it will automatically get \u201cexpanded\u201d out to the full definition. This makes it useful e.g. to reuse plain Haskell code to compose specifications, and to share definitions common to refinements and code. However, as they are expanded at compile time, inline functions cannot be recursive . The can call other (non-recursive) inline functions. If you want to talk about arbitrary (recursive) functions inside your types, then you need to use reflect described in the blog . Self-Invariants \u00b6 Sometimes, we require specifications that allow inner components of a type to refer to the outer components, typically, to measure-based properties of outer components. For example, the following invariant about Maybe values {-@ type IMaybe a = {v0 : Maybe {v : a | ((isJust v0) && v = (fromJust v0))} | 0 = 0 } @-} states that the inner a enjoys the property that the outer container is definitely a Just and furthermore, the inner value is exactly the same as the fromJust property of the outer container. As another example, suppose we have a measure : measure listElts :: [a] -> (Set a) listElts([]) = {v | (? Set_emp(v))} listElts(x:xs) = {v | v = Set_cup(Set_sng(x), listElts(xs)) } Now, all lists enjoy the property {-@ type IList a = {v0 : List {v : a | (Set_mem v (listElts v0)) } | true } @-} which simply states that each inner element is indeed, a member of the set of the elements belonging to the entire list. One often needs these circular or self invariants to connect different levels (or rather, to reify the connections between the two levels.) See this test for a simple example and hedgeUnion and Data.Map.Base for a complex one. Abstract and Bounded Refinements \u00b6 This is probably the best example of the abstract refinement syntax: Abstract Refinements Bounded Refinements Unfortunately, the best documentation for these two advanced features is the relevant papers at: ESOP 2013 ICFP 2015 The bounds correspond to Horn implications between abstract refinements, which, as in the classical setting, correspond to subtyping constraints that must be satisfied by the concrete refinements used at any call-site. Dependent Pairs \u00b6 Dependent Pairs are expressed by binding the initial tuples of the pair. For example incrPair defines an increasing pair. {-@ incrPair :: Int -> (x::Int, {v:Int | x <= v}) @-} incrPair i = (i, i+1) Internally dependent pairs are implemented using abstract refinement types. That is (x::a, {v:b | p x}) desugars to (a,b)<\\x -> {v:b | p x}> . Invariants \u00b6 LH lets you locally associate invariants with specific data types. For example, in tests/measure/pos/Using00.hs every list is treated as a Stream . To establish this local invariant one can use the using declaration {-@ using ([a]) as {v:[a] | (len v > 0)} @-} denoting that each list is not empty. Then, LiquidHaskell will prove that this invariant holds, by proving that all calls to List's constructors (ie., : and [] ) satisfy it, and will assume that each list element that is created satisfies this invariant. With this, at the above test LiquidHaskell proves that taking the head of a list is safe. But, at tests/measure/neg/Using00.hs the usage of [] falsifies this local invariant resulting in an \"Invariant Check\" error. WARNING: There is an older global invariant mechanism that attaches a refinement to a datatype globally. Do not use this mechanism -- it is unsound and about to deprecated in favor of something that is actually sound For example, the length of a list cannot be negative {-@ invariant {v:[a] | (len v >= 0)} @-} LiquidHaskell can prove that this invariant holds, by proving that all List's constructors (ie., : and [] ) satisfy it.(TODO!) Then, LiquidHaskell assumes that each list element that is created satisfies this invariant. Rewriting \u00b6 Status: experimental You use the rewriteWith annotation to indicate equalities that PLE will apply automatically. For example, suppose that you have proven associativity of ++ for lists. {-@ assoc :: xs:[a] -> ys:[a] -> zs:[a] -> { xs ++ (ys ++ zs) == (xs ++ ys) ++ zs } @-} Using the rewriteWith annotation, PLE will automatically apply the equality for associativity whenever it encounters an expression of the form xs ++ (ys ++ zs) or (xs ++ ys) ++ zs . For example, you can prove assoc2 for free. {-@ rewriteWith assoc2 [assoc] @-} {-@ assoc2 :: xs:[a] -> ys:[a] -> zs:[a] -> ws:[a] -> { xs ++ (ys ++ (zs ++ ws)) == ((xs ++ ys) ++ zs) ++ ws } @-} assoc2 :: [a] -> [a] -> [a] -> [a] -> () assoc2 xs ys zs ws = () You can also annotate a function as being a global rewrite rule by using the rewrite annotation, in which case PLE will apply it across the entire module. {-@ rewrite assoc @-} {-@ assoc :: xs:[a] -> ys:[a] -> zs:[a] -> { xs ++ (ys ++ zs) == (xs ++ ys) ++ zs } @-} Limitations \u00b6 Currently, rewriting does not work if the equality that uses the rewrite rule includes parameters that contain inner refinements ( test ). Rewriting works by pattern-matching expressions to determine if there is a variable substitution that would allow it to match against either side of a rewrite rule. If so, that substitution is applied to the opposite side and the corresponding equality is generated. If one side of the equality contains any parameters that are not bound on the other side, it will not be possible to generate a rewrite in that direction, because those variables cannot be instantiated. Likewise, if there are free variables on both sides of an equality, no rewrite can be generated at all ( test ). It's possible in theory for rewriting rules to diverge. We have a simple check to ensure that rewriting rules that will always diverge do not get instantiated. However, it's possible that applying a combination of rewrite rules could cause divergence. Formal Grammar of Refinement Predicates \u00b6 (C)onstants \u00b6 c := 0, 1, 2, ... (V)ariables \u00b6 v := x, y, z, ... (E)xpressions \u00b6 e := v -- variable | c -- constant | (e + e) -- addition | (e - e) -- subtraction | (c * e) -- multiplication by constant | (v e1 e2 ... en) -- uninterpreted function application | (if p then e else e) -- if-then-else (R)elations \u00b6 r := == -- equality | /= -- disequality | >= -- greater than or equal | <= -- less than or equal | > -- greater than | < -- less than (P)redicates \u00b6 p := (e r e) -- binary relation | (v e1 e2 ... en) -- predicate (or alias) application | (p && p) -- and | (p || p) -- or | (p => p) -- implies | (not p) -- negation | true | false Specifying Qualifiers \u00b6 There are several ways to specify qualifiers. By Separate .hquals Files \u00b6 You can write qualifier files e.g. Prelude.hquals .. If a module is called or imports Foo.Bar.Baz Then the system automatically searches for include/Foo/Bar/Baz.hquals By Including .hquals Files \u00b6 Additional qualifiers may be used by adding lines of the form: {-@ include <path/to/file.hquals> @-} to the Haskell source. See, this for example. In Haskell Source or Spec Files \u00b6 Finally, you can specifiers directly inside source (.hs or .lhs) or spec (.spec) files by writing as shown here {-@ qualif Foo(v:Int, a: Int) : (v = a + 100) @-} Note In addition to these, LiquidHaskell scrapes qualifiers from all the specifications you write i.e. all imported type signatures, measure bodies and, data constructor definitions. Termination Metrics \u00b6 In recursive functions the first algebraic or integer argument should be decreasing. The default decreasing measure for lists is length and Integers its value. Default Termination Metrics \u00b6 The user can specify the size of a data-type in the data definition {-@ data L [llen] a = Nil | Cons { x::a, xs:: L a} @-} In the above, the measure llen , which needs to be defined by the user (see below), is defined as the default metric for the type L a . LH will use this default metric to automatically prove that the following terminates: append :: L a -> L a -> L a append N ys = ys append (Cons x xs) ys = Cons x (append xs ys) as, by default the first (non-function) argument with an associated size metric is checked to be strictly terminating and non-negative at each recursive call. A default termination metric is a Haskell function that is proved terminating using structural induction. To deactivate structional induction check on the termination metric, use the --trust-sizes flag. Explicit Termination Metrics \u00b6 However, consider the function reverse : reverseAcc :: L a -> L a -> L a reverseAcc acc N = acc reverseAcc acc (Cons x xs) = reverseAcc (Cons x acc) xs Here, the first argument does not decrease, instead the second does. We can tell LH to use the second argument using the explicit termination metric reverseAcc :: L a -> xs:L a -> L a / [llen xs] which tells LH that the llen of the second argument xs is what decreases at each recursive call. Decreasing expressions can be arbitrary refinement expressions, e.g., {-@ merge :: Ord a => xs:L a -> ys:L a -> L a / [llen xs + llen ys] @-} states that at each recursive call of merge the sum of the lengths of its arguments will decrease. Lexicographic Termination Metrics \u00b6 Some functions do not decrease on a single argument, but rather a combination of arguments, e.g. the Ackermann function. {-@ ack :: m:Int -> n:Int -> Nat / [m, n] @-} ack m n | m == 0 = n + 1 | m > 0 && n == 0 = ack (m-1) 1 | m > 0 && n > 0 = ack (m-1) (ack m (n-1)) In all but one recursive call m decreases, in the final call m does not decrease but n does. We can capture this notion of m normally decreases, but if it does not, n will decrease with a lexicographic termination metric [m, n] . An alternative way to express this specification is by annotating the function's type with the appropriate numeric decreasing expressions. As an example, you can give ack a type {-@ ack :: m:Nat -> n:Nat -> Nat / [m,n] @-} stating that the numeric expressions [m, n] are lexicographically decreasing. Mutually Recursive Functions \u00b6 When dealing with mutually recursive functions you may run into a situation where the decreasing parameter must be measured across a series of invocations, e.g. even :: Int -> Bool even 0 = True even n = odd (n-1) odd :: Int -> Bool odd n = not (even n) In this case, you can introduce a ghost parameter that orders the functions {-@ isEven :: n:Nat -> Bool / [n, 0] @-} isEven :: Int -> Bool isEven 0 = True isEven n = isOdd (n-1) {-@ isOdd :: n:Nat -> Bool / [n, 1] @-} isOdd :: Int -> Bool isOdd n = not $ isEven n thus recovering a decreasing measure for the pair of functions, the pair of arguments. This can be encoded with the lexicographic termination annotation as shown above. See tests/pos/mutrec.hs for the full example. Automatic Termination Metrics \u00b6 Apart from specifying a specific decreasing measure for an Algebraic Data Type, the user can specify that the ADT follows the expected decreasing measure by {-@ autosize L @-} Then, LH will define an instance of the function autosize for L that decreases by 1 at each recursive call and use autosize at functions that recurse on L . For example, autosize L will refine the data constructors of L a with the autosize :: a -> Int information, such that Nil :: {v:L a | autosize v = 0} Cons :: x:a -> xs:L a -> {v:L a | autosize v = 1 + autosize xs} Also, an invariant that autosize is non negative will be generated invariant {v:L a| autosize v >= 0 } This information is all LiquidHaskell needs to prove termination on functions that recurse on L a (on ADTs in general.) Disabling Termination Checking \u00b6 To disable termination checking for foo that is, to assume that it is terminating (possibly for some complicated reason currently beyond the scope of LH) you can write {-@ lazy foo @-} Synthesis \u00b6 Status: experimental LH has some very preliminary support for program synthesis. How to use it \u00b6 Activate the flag for typed holes in LiquidHaskell. E.g. from command line: liquid --typedholes In a Haskell source file: {-@ LIQUID --typed-holes @-} Using the flag for typed holes, two more flags can be used: max-match-depth : Maximum number of pattern match expressions used during synthesis (default value: 4). max-app-depth : Maximum number of same function applications used during synthesis (default value: 2). Having the program specified in a Haskell source file, use GHC' s hole variables, e.g.: {-@ myMap :: (a -> b) -> xs:[a] -> {v:[b] | len v == len xs} @-} myMap :: (a -> b) -> [a] -> [b] myMap = _goal Limitations \u00b6 This is an experimental feature, so potential users could only expect to synthesize programs, like these . Current limitations include: No boolean conditionals are synthesized. Holes can only appear at top level, e.g.: {-@ f :: x: [a] -> { v: [a] | v == x } @-} f :: [a] -> [a] -- This works f = _hole -- This does not work f x = _hole Only one hole can appear in each module.","title":"Specifications"},{"location":"specifications/#writing-specifications","text":"This section documents how you can actually annotate new or existing code with refinement types, leveraging the full power of LiquidHaskell. There are a lot of different ways to annotate your code, and so we've included a brief summary of each here. {-@ inline <binding-name> @-} copies a Haskell definition to the refinement logic. ( Jump to: Inlines ) All parts of the definition must already be available to the refinement logic. The definition cannot be recursive. {-@ measure <function-name>[ <refinement-type>] @-} copies a Haskell function to the refinement logic, adds an inferred refinement type to the constructor of the function's first argument, and emits an inferred global invariant related to the refinement. ( Jump to: Measures ) All parts of the definition must already be available to the refinement logic. The function must have only one argument and it must pattern match on the constructors of the type. The function may structurally recurse on the single argument. {-@ reflect <function-name> @-} creates an uninterpreted function of the same name in the refinement logic, copies the implementation to a refinement type alias, and adds a refinement to the type of the uninterpreted function that specifies the type alias as a post-condition. ( See more: Section 2.2 of this paper ) All parts of the definition must already be available to the refinement logic. The function may be recursive. {-@ type <type-alias-head> = <refinement-type> @-} introduces a type alias that looks like Haskell syntax but can contain refinements and may be parameterized over both types and values. ( Jump to: Type Aliases ) {-@ predicate .. @-} introduces something like {-@ type .. @-} . ( Deprecated, use inline instead , Jump to: Predicate Aliases ) {-@ invariant <refinement-type> @-} introduces a globally available refinement which may be used by Liquid Haskel, but is not checked. ( Unchecked , Deprecated , Jump to: Invariants ) {-@ data <data-type-head><termination-measure>[ <data-type-body] @-} introduces a refined datatype, and introduces measures for each field of a record datatype. ( Jump to: Data Refinements ) Optionally you may also add refinements to datatype fields. Optionally you may also add a termination measure to the datatype. {-@ assume <binding-signature-with-refinement-type> @-} introduces a refinement type for the named Haskell definition. ( Unchecked ) For a function, the refinements become pre and post conditions for the functions use. {-@ <binding-signature-with-refinement-type> @-} introduces a refinement type for the named Haskell definition. For a function, the refinements become pre and post conditions for the functions use. This is probably the most used Liquid Haskell annotation! The following sections detail more variety for the uses of the above annotations.","title":"Writing Specifications"},{"location":"specifications/#modules-without-code","text":"The following section is slightly different depending on whether you are using the plugin (which you should!) or the legacy executable.","title":"Modules WITHOUT code"},{"location":"specifications/#plugin-adding-refinements-for-external-modules","text":"See the plugin section, which cointains a link to a walkthrough document that describes how to add refinements for external packages (cfr. \"Providing Specifications for Existing Packages\" )","title":"(Plugin) Adding refinements for external modules"},{"location":"specifications/#legacy-executable-adding-refinements-for-external-modules","text":"When checking a file target.hs , you can specify an include directory by liquid -i /path/to/include/ target.hs Now, to write specifications for some external module Foo.Bar.Baz for which you do not have the code , you can create a .spec file at: /path/to/include/Foo/Bar/Baz.spec See, for example, the contents of: include/Prelude.spec include/Data/List.spec include/Data/Vector.spec Note : The above directories are part of the LH prelude, and included by default when running liquid . The .spec mechanism is only for external modules without code, see below for standalone specifications for internal or home * modules.","title":"(Legacy executable) Adding refinements for external modules"},{"location":"specifications/#modules-with-code-data","text":"Write the specification directly into the .hs or .lhs file, above the data definition. See, for example, tests/pos/Map.hs : {-@ data Map k a <l :: k -> k -> Prop, r :: k -> k -> Prop> = Tip | Bin (sz :: Size) (key :: k) (value :: a) (left :: Map <l, r> (k <l key>) a) (right :: Map <l, r> (k <r key>) a) @-} data Map k a = Tip | Bin Size k a (Map k a) (Map k a) You can also write invariants for data type definitions together with the types. For example, see tests/pos/record0.hs : {-@ data LL a = BXYZ { size :: {v: Int | v > 0 } , elems :: {v: [a] | (len v) = size } } @-} Finally you can specify the variance of type variables for data types. For example, see tests/pos/Variance.hs , where data type Foo has four type variables a , b , c , d , specified as invariant, bivariant, covariant and contravariant, respectively. {-@ data variance Foo invariant bivariant covariant contravariant @-} data Foo a b c d","title":"Modules WITH code: Data"},{"location":"specifications/#modules-with-code-functions","text":"Write the specification directly into the .hs or .lhs file, above the function definition. For example : {-@ incr :: x:{v: Int | v > 0} -> {v: Int | v > x} @-} incr :: Int -> Int incr x = x + 1","title":"Modules WITH code: Functions"},{"location":"specifications/#modules-with-code-type-classes","text":"Write the specification directly into the .hs or .lhs file, above the type class definition. For example : {-@ class Sized s where size :: forall a. x:s a -> {v:Int | v = (size x)} @-} class Sized s where size :: s a -> Int Any measures used in the refined class definition will need to be generic (see Specifying Measures ). As an alternative, you can refine class instances. For example : instance Compare Int where {-@ instance Compare Int where cmax :: Odd -> Odd -> Odd @-} cmax y x = if x >= y then x else y When cmax method is used on Int , liquidHaskell will give it the refined type Odd -> Odd -> Odd . Note that currently liquidHaskell does not allow refining instances of refined classes .","title":"Modules WITH code: Type Classes"},{"location":"specifications/#modules-with-code-quasiquotation","text":"Instead of writing both a Haskell type signature and a LiquidHaskell specification for a function, the lq quasiquoter in the LiquidHaskell module can be used to generate both from just the LiquidHaskell specification. module Nats (nats) where {-@ nats :: [{v:Int | 0 <= v}] @-} nats :: [Int] nats = [1,2,3] can be written as {-# LANGUAGE QuasiQuotes #-} module Nats (nats) where import LiquidHaskell [lq| nats :: [{v:Int | 0 <= v}] |] nats = [1,2,3] and the lq quasiquoter will generate the plain nats :: [Int] when GHC compiles the module. Refined type aliases (see the next section) can also be written inside lq ; for example: {-# LANGUAGE QuasiQuoters #-} module Nats (Nat, nats) where [lq| type Nat = {v:Int | 0 <= v} |] [lq| nats :: [Nat] |] nats = [1,2,3] Here, the lq quasiquoter will generate a plain Haskell type synonym for Nat as well as the refined one. Note that this is still an experimental feature, and currently requires that one depend on LiquidHaskell as a build dependency for your project; the quasiquoter will be split out eventually into an independent, dependency-light package. Also, at this time, writing a type inside lq which refers to a refined type alias for which there is not a plain Haskell type synonym of the same name will result in a \"not in scope\" error from GHC.","title":"Modules WITH code: QuasiQuotation"},{"location":"specifications/#standalone-specifications-for-internal-modules","text":"Recall that the .spec mechanism is only for modules whose code is absent; if code is present then there can be multiple, possibly conflicting specifications. Nevertheless, you may want, for one reason or another, to write (assumed) specifications outside the file implementing the module. You can do this as follows. Lib.hs module Lib (foo) where foo a = a now, instead of a .spec file, just use a haskell module, e.g. LibSpec.hs module LibSpec ( module Lib ) where import Lib -- Don't forget to qualify the name! {-@ Lib.foo :: {v:a | false} -> a @-} and then here's Client.hs module Client where import Lib -- use this if you DON'T want the spec import LibSpec -- use this if you DO want the spec, in addition to OR instead of the previous import. bar = foo 1 -- if you `import LibSpec` then this call is rejected by LH","title":"Standalone Specifications for Internal Modules"},{"location":"specifications/#inductive-predicates","text":"Status: very_experimental LH recently added support for Inductive Predicates in the style of Isabelle, Coq etc. These are encoded simply as plain Haskell GADTs but suitably refined. Apologies for the minimal documentation; see the following examples for details: Palindrome Permutations Transitive Closure RegExp Derivatives Type Safety of STLC","title":"Inductive Predicates"},{"location":"specifications/#implicit-arguments","text":"Status: experimental There is experimental support for implicit arguments, solved for with congruence closure. For example, consider Implicit1.hs : {-@ type IntN N = {v:Int | v = N} @-} {-@ foo :: n:Int ~> (() -> IntN n) -> IntN {n+1} @-} foo f = 1 + f () {-@ test1 :: IntN 11 @-} test1 = foo (\\_ -> 10) Here, the refinement on (\\_ -> 10) :: Int -> { v:Int | v = 10 } allows us to solve for n = 10 , the implicit argument to foo .","title":"Implicit Arguments"},{"location":"specifications/#refinement-type-aliases","text":"","title":"Refinement Type Aliases"},{"location":"specifications/#predicate-aliases","text":"Often, the propositions in the refinements can get rather long and verbose. You can write predicate aliases like so: {-@ predicate Lt X Y = X < Y @-} {-@ predicate Ge X Y = not (Lt X Y) @-} and then use the aliases inside refinements, for example {-@ incr :: x:{v:Int | (Pos v)} -> { v:Int | ((Pos v) && (Ge v x))} @-} incr :: Int -> Int incr x = x + 1 See Data.Map for a more substantial and compelling example. Syntax: The key requirements for type aliases are: Value parameters are specified in upper case: X , Y , Z etc.","title":"Predicate Aliases"},{"location":"specifications/#failing-specifications","text":"The fail b declaration checks that the definition of b is unsafe. E.g., the following is SAFE. {-@ fail unsafe @-} {-@ unsafe :: () -> { 0 == 1 } @-} unsafe :: () -> () unsafe _ = () An error is created if fail definitions are safe or binders defined as fail are used by (failing or not) definitions.","title":"Failing Specifications"},{"location":"specifications/#type-aliases","text":"Similarly, it is often quite tedious to keep writing {v: Int | v > 0} Thus, LiquidHaskell supports refinement-type aliases of the form: {-@ type Gt N = {v: Int | N < v} @-} {-@ type GeNum a N = {v: a | N <= v} @-} or {-@ type SortedList a = [a]<{\\fld v -> (v >= fld)}> @-} or {-@ type OMap k a = Map <{\\root v -> v < root}, {\\root v -> v > root}> k a @-} or {-@ type MinSPair a = (a, OSplay a) <\\fld -> {v : Splay {v:a|v>fld} | 0=0}> @-} and then use the above in signatures like: {-@ incr: x: Int -> GeNum Int x @-} or {-@ incr: x: Int -> Gt x @-} and: {-@ assert insert :: (Ord a) => a -> SortedList a -> SortedList a @-} see tests/pos/ListSort.hs and: {-@ assert insert :: (Ord k) => k -> a -> OMap k a -> OMap k a @-} see tests/pos/Map.hs Syntax: The key requirements for type aliases are: Type parameters are specified in lower case: a , b , c etc. Value parameters are specified in upper case: X , Y , Z etc.","title":"Type Aliases"},{"location":"specifications/#infix-operators","text":"You can define infix types and logical operators in logic Haskell's infix notation . For example, if (+++) is defined as a measure or reflected function, you can use it infix by declaring {-@ infixl 9 +++ @-} Note: infix operators cannot contain the dot character . . If (==>) is a Haskell infix type ( see ) infixr 1 ==> then to use it as infix in the refinements types you need to add the refinement infix notation. {-@ infixr 1 ==> @-} {-@ test :: g:(f ==> g) -> f x -> f y -> () @-}","title":"Infix  Operators"},{"location":"specifications/#specifying-measures","text":"They can be placed in a .spec file or in a .hs/.lhs file wrapped around {-@ @-} . Value measures: GHC/Base.spec measure len :: forall a. [a] -> GHC.Types.Int len ([]) = 0 len (y:ys) = 1 + len(ys) Propositional measures: tests/pos/LambdaEval.hs {-@ measure isValue :: Expr -> Bool isValue (Const i) = true isValue (Lam x e) = true isValue (Var x) = false isValue (App e1 e2) = false isValue (Plus e1 e2) = false isValue (Fst e) = false isValue (Snd e) = false isValue (Pair e1 e2) = ((? (isValue(e1))) && (? (isValue(e2)))) @-} Raw measures: tests/pos/meas8.hs {-@ measure rlen :: [a] -> Int rlen ([]) = {v | v = 0} rlen (y:ys) = {v | v = (1 + rlen(ys))} @-} Generic measures: tests/pos/Class.hs {-@ class measure size :: a -> Int @-} {-@ instance measure size :: [a] -> Int size ([]) = 0 size (x:xs) = 1 + (size xs) @-} {-@ instance measure size :: Tree a -> Int size (Leaf) = 0 size (Node x l r) = 1 + (size l) + (size r) @-} Note: Measure names do not have to be the same as field name, e.g. we could call the measure sz in the above as shown in tests/pos/Class2.hs . Haskell Functions as Measures (beta): tests/pos/HaskellMeasure.hs Inductive Haskell Functions from Data Types to some type can be lifted to logic {-@ measure llen @-} llen :: [a] -> Int llen [] = 0 llen (x:xs) = 1 + llen xs The above definition: refines list's data constructors types with the llen information, and specifies a singleton type for the haskell function llen :: xs:[a] -> {v:Int | v == llen xs} . If the user specifies another type for llen , say llen :: xs:[a] -> {v:Int | llen xs >= 0} , then the auto generated singleton type is overwritten.","title":"Specifying Measures"},{"location":"specifications/#inlines","text":"The inline lets you use a Haskell function in a type specification. {-@ inline max @-} {-@ max :: Int -> Int -> Int @-} max :: Int -> Int -> Int max x y = if x > y then x else y For example, if you write the above you can then write a function: {-@ floor :: x:Int -> {v:Int | max 0 x} @-} floor :: Int -> Int floor x | x <= 0 = 0 | otherwise = x That is, you can use the haskell max in the refinement type and it will automatically get \u201cexpanded\u201d out to the full definition. This makes it useful e.g. to reuse plain Haskell code to compose specifications, and to share definitions common to refinements and code. However, as they are expanded at compile time, inline functions cannot be recursive . The can call other (non-recursive) inline functions. If you want to talk about arbitrary (recursive) functions inside your types, then you need to use reflect described in the blog .","title":"Inlines"},{"location":"specifications/#self-invariants","text":"Sometimes, we require specifications that allow inner components of a type to refer to the outer components, typically, to measure-based properties of outer components. For example, the following invariant about Maybe values {-@ type IMaybe a = {v0 : Maybe {v : a | ((isJust v0) && v = (fromJust v0))} | 0 = 0 } @-} states that the inner a enjoys the property that the outer container is definitely a Just and furthermore, the inner value is exactly the same as the fromJust property of the outer container. As another example, suppose we have a measure : measure listElts :: [a] -> (Set a) listElts([]) = {v | (? Set_emp(v))} listElts(x:xs) = {v | v = Set_cup(Set_sng(x), listElts(xs)) } Now, all lists enjoy the property {-@ type IList a = {v0 : List {v : a | (Set_mem v (listElts v0)) } | true } @-} which simply states that each inner element is indeed, a member of the set of the elements belonging to the entire list. One often needs these circular or self invariants to connect different levels (or rather, to reify the connections between the two levels.) See this test for a simple example and hedgeUnion and Data.Map.Base for a complex one.","title":"Self-Invariants"},{"location":"specifications/#abstract-and-bounded-refinements","text":"This is probably the best example of the abstract refinement syntax: Abstract Refinements Bounded Refinements Unfortunately, the best documentation for these two advanced features is the relevant papers at: ESOP 2013 ICFP 2015 The bounds correspond to Horn implications between abstract refinements, which, as in the classical setting, correspond to subtyping constraints that must be satisfied by the concrete refinements used at any call-site.","title":"Abstract and Bounded Refinements"},{"location":"specifications/#dependent-pairs","text":"Dependent Pairs are expressed by binding the initial tuples of the pair. For example incrPair defines an increasing pair. {-@ incrPair :: Int -> (x::Int, {v:Int | x <= v}) @-} incrPair i = (i, i+1) Internally dependent pairs are implemented using abstract refinement types. That is (x::a, {v:b | p x}) desugars to (a,b)<\\x -> {v:b | p x}> .","title":"Dependent Pairs"},{"location":"specifications/#invariants","text":"LH lets you locally associate invariants with specific data types. For example, in tests/measure/pos/Using00.hs every list is treated as a Stream . To establish this local invariant one can use the using declaration {-@ using ([a]) as {v:[a] | (len v > 0)} @-} denoting that each list is not empty. Then, LiquidHaskell will prove that this invariant holds, by proving that all calls to List's constructors (ie., : and [] ) satisfy it, and will assume that each list element that is created satisfies this invariant. With this, at the above test LiquidHaskell proves that taking the head of a list is safe. But, at tests/measure/neg/Using00.hs the usage of [] falsifies this local invariant resulting in an \"Invariant Check\" error. WARNING: There is an older global invariant mechanism that attaches a refinement to a datatype globally. Do not use this mechanism -- it is unsound and about to deprecated in favor of something that is actually sound For example, the length of a list cannot be negative {-@ invariant {v:[a] | (len v >= 0)} @-} LiquidHaskell can prove that this invariant holds, by proving that all List's constructors (ie., : and [] ) satisfy it.(TODO!) Then, LiquidHaskell assumes that each list element that is created satisfies this invariant.","title":"Invariants"},{"location":"specifications/#rewriting","text":"Status: experimental You use the rewriteWith annotation to indicate equalities that PLE will apply automatically. For example, suppose that you have proven associativity of ++ for lists. {-@ assoc :: xs:[a] -> ys:[a] -> zs:[a] -> { xs ++ (ys ++ zs) == (xs ++ ys) ++ zs } @-} Using the rewriteWith annotation, PLE will automatically apply the equality for associativity whenever it encounters an expression of the form xs ++ (ys ++ zs) or (xs ++ ys) ++ zs . For example, you can prove assoc2 for free. {-@ rewriteWith assoc2 [assoc] @-} {-@ assoc2 :: xs:[a] -> ys:[a] -> zs:[a] -> ws:[a] -> { xs ++ (ys ++ (zs ++ ws)) == ((xs ++ ys) ++ zs) ++ ws } @-} assoc2 :: [a] -> [a] -> [a] -> [a] -> () assoc2 xs ys zs ws = () You can also annotate a function as being a global rewrite rule by using the rewrite annotation, in which case PLE will apply it across the entire module. {-@ rewrite assoc @-} {-@ assoc :: xs:[a] -> ys:[a] -> zs:[a] -> { xs ++ (ys ++ zs) == (xs ++ ys) ++ zs } @-}","title":"Rewriting"},{"location":"specifications/#limitations","text":"Currently, rewriting does not work if the equality that uses the rewrite rule includes parameters that contain inner refinements ( test ). Rewriting works by pattern-matching expressions to determine if there is a variable substitution that would allow it to match against either side of a rewrite rule. If so, that substitution is applied to the opposite side and the corresponding equality is generated. If one side of the equality contains any parameters that are not bound on the other side, it will not be possible to generate a rewrite in that direction, because those variables cannot be instantiated. Likewise, if there are free variables on both sides of an equality, no rewrite can be generated at all ( test ). It's possible in theory for rewriting rules to diverge. We have a simple check to ensure that rewriting rules that will always diverge do not get instantiated. However, it's possible that applying a combination of rewrite rules could cause divergence.","title":"Limitations"},{"location":"specifications/#formal-grammar-of-refinement-predicates","text":"","title":"Formal Grammar of Refinement Predicates"},{"location":"specifications/#constants","text":"c := 0, 1, 2, ...","title":"(C)onstants"},{"location":"specifications/#variables","text":"v := x, y, z, ...","title":"(V)ariables"},{"location":"specifications/#expressions","text":"e := v -- variable | c -- constant | (e + e) -- addition | (e - e) -- subtraction | (c * e) -- multiplication by constant | (v e1 e2 ... en) -- uninterpreted function application | (if p then e else e) -- if-then-else","title":"(E)xpressions"},{"location":"specifications/#relations","text":"r := == -- equality | /= -- disequality | >= -- greater than or equal | <= -- less than or equal | > -- greater than | < -- less than","title":"(R)elations"},{"location":"specifications/#predicates","text":"p := (e r e) -- binary relation | (v e1 e2 ... en) -- predicate (or alias) application | (p && p) -- and | (p || p) -- or | (p => p) -- implies | (not p) -- negation | true | false","title":"(P)redicates"},{"location":"specifications/#specifying-qualifiers","text":"There are several ways to specify qualifiers.","title":"Specifying Qualifiers"},{"location":"specifications/#by-separate-hquals-files","text":"You can write qualifier files e.g. Prelude.hquals .. If a module is called or imports Foo.Bar.Baz Then the system automatically searches for include/Foo/Bar/Baz.hquals","title":"By Separate .hquals Files"},{"location":"specifications/#by-including-hquals-files","text":"Additional qualifiers may be used by adding lines of the form: {-@ include <path/to/file.hquals> @-} to the Haskell source. See, this for example.","title":"By Including .hquals Files"},{"location":"specifications/#in-haskell-source-or-spec-files","text":"Finally, you can specifiers directly inside source (.hs or .lhs) or spec (.spec) files by writing as shown here {-@ qualif Foo(v:Int, a: Int) : (v = a + 100) @-} Note In addition to these, LiquidHaskell scrapes qualifiers from all the specifications you write i.e. all imported type signatures, measure bodies and, data constructor definitions.","title":"In Haskell Source or Spec Files"},{"location":"specifications/#termination-metrics","text":"In recursive functions the first algebraic or integer argument should be decreasing. The default decreasing measure for lists is length and Integers its value.","title":"Termination Metrics"},{"location":"specifications/#default-termination-metrics","text":"The user can specify the size of a data-type in the data definition {-@ data L [llen] a = Nil | Cons { x::a, xs:: L a} @-} In the above, the measure llen , which needs to be defined by the user (see below), is defined as the default metric for the type L a . LH will use this default metric to automatically prove that the following terminates: append :: L a -> L a -> L a append N ys = ys append (Cons x xs) ys = Cons x (append xs ys) as, by default the first (non-function) argument with an associated size metric is checked to be strictly terminating and non-negative at each recursive call. A default termination metric is a Haskell function that is proved terminating using structural induction. To deactivate structional induction check on the termination metric, use the --trust-sizes flag.","title":"Default Termination Metrics"},{"location":"specifications/#explicit-termination-metrics","text":"However, consider the function reverse : reverseAcc :: L a -> L a -> L a reverseAcc acc N = acc reverseAcc acc (Cons x xs) = reverseAcc (Cons x acc) xs Here, the first argument does not decrease, instead the second does. We can tell LH to use the second argument using the explicit termination metric reverseAcc :: L a -> xs:L a -> L a / [llen xs] which tells LH that the llen of the second argument xs is what decreases at each recursive call. Decreasing expressions can be arbitrary refinement expressions, e.g., {-@ merge :: Ord a => xs:L a -> ys:L a -> L a / [llen xs + llen ys] @-} states that at each recursive call of merge the sum of the lengths of its arguments will decrease.","title":"Explicit Termination Metrics"},{"location":"specifications/#lexicographic-termination-metrics","text":"Some functions do not decrease on a single argument, but rather a combination of arguments, e.g. the Ackermann function. {-@ ack :: m:Int -> n:Int -> Nat / [m, n] @-} ack m n | m == 0 = n + 1 | m > 0 && n == 0 = ack (m-1) 1 | m > 0 && n > 0 = ack (m-1) (ack m (n-1)) In all but one recursive call m decreases, in the final call m does not decrease but n does. We can capture this notion of m normally decreases, but if it does not, n will decrease with a lexicographic termination metric [m, n] . An alternative way to express this specification is by annotating the function's type with the appropriate numeric decreasing expressions. As an example, you can give ack a type {-@ ack :: m:Nat -> n:Nat -> Nat / [m,n] @-} stating that the numeric expressions [m, n] are lexicographically decreasing.","title":"Lexicographic Termination Metrics"},{"location":"specifications/#mutually-recursive-functions","text":"When dealing with mutually recursive functions you may run into a situation where the decreasing parameter must be measured across a series of invocations, e.g. even :: Int -> Bool even 0 = True even n = odd (n-1) odd :: Int -> Bool odd n = not (even n) In this case, you can introduce a ghost parameter that orders the functions {-@ isEven :: n:Nat -> Bool / [n, 0] @-} isEven :: Int -> Bool isEven 0 = True isEven n = isOdd (n-1) {-@ isOdd :: n:Nat -> Bool / [n, 1] @-} isOdd :: Int -> Bool isOdd n = not $ isEven n thus recovering a decreasing measure for the pair of functions, the pair of arguments. This can be encoded with the lexicographic termination annotation as shown above. See tests/pos/mutrec.hs for the full example.","title":"Mutually Recursive Functions"},{"location":"specifications/#automatic-termination-metrics","text":"Apart from specifying a specific decreasing measure for an Algebraic Data Type, the user can specify that the ADT follows the expected decreasing measure by {-@ autosize L @-} Then, LH will define an instance of the function autosize for L that decreases by 1 at each recursive call and use autosize at functions that recurse on L . For example, autosize L will refine the data constructors of L a with the autosize :: a -> Int information, such that Nil :: {v:L a | autosize v = 0} Cons :: x:a -> xs:L a -> {v:L a | autosize v = 1 + autosize xs} Also, an invariant that autosize is non negative will be generated invariant {v:L a| autosize v >= 0 } This information is all LiquidHaskell needs to prove termination on functions that recurse on L a (on ADTs in general.)","title":"Automatic Termination Metrics"},{"location":"specifications/#disabling-termination-checking","text":"To disable termination checking for foo that is, to assume that it is terminating (possibly for some complicated reason currently beyond the scope of LH) you can write {-@ lazy foo @-}","title":"Disabling Termination Checking"},{"location":"specifications/#synthesis","text":"Status: experimental LH has some very preliminary support for program synthesis.","title":"Synthesis"},{"location":"specifications/#how-to-use-it","text":"Activate the flag for typed holes in LiquidHaskell. E.g. from command line: liquid --typedholes In a Haskell source file: {-@ LIQUID --typed-holes @-} Using the flag for typed holes, two more flags can be used: max-match-depth : Maximum number of pattern match expressions used during synthesis (default value: 4). max-app-depth : Maximum number of same function applications used during synthesis (default value: 2). Having the program specified in a Haskell source file, use GHC' s hole variables, e.g.: {-@ myMap :: (a -> b) -> xs:[a] -> {v:[b] | len v == len xs} @-} myMap :: (a -> b) -> [a] -> [b] myMap = _goal","title":"How to use it"},{"location":"specifications/#limitations_1","text":"This is an experimental feature, so potential users could only expect to synthesize programs, like these . Current limitations include: No boolean conditionals are synthesized. Holes can only appear at top level, e.g.: {-@ f :: x: [a] -> { v: [a] | v == x } @-} f :: [a] -> [a] -- This works f = _hole -- This does not work f x = _hole Only one hole can appear in each module.","title":"Limitations"}]}